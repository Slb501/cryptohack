
\section{Challenges : RSA}
\subsection{Introduction au cryptosystème RSA}
Dans cette catégorie, nous abordons le cryptosystème à clé publique RSA, décrit pour la première fois en 1977. C’est l’un des systèmes de chiffrement asymétrique les plus connus et les plus utilisés dans le monde.

Nous nous appuyons sur le principe fondamental de RSA : la difficulté de factoriser de grands nombres composés en leurs facteurs premiers. Cette propriété mathématique nous permet de garantir la sécurité du système, à condition de choisir et d’implémenter correctement les paramètres.

Le cryptosystème RSA possède deux usages principaux. Le premier est le chiffrement, où nous publions une clé publique permettant à d’autres de nous envoyer des messages chiffrés, que nous pouvons ensuite déchiffrer grâce à notre clé privée. Le second est la signature numérique, qui nous permet de signer un message avec notre clé privée, afin que quiconque puisse vérifier l’authenticité et l’intégrité du message à l’aide de la clé publique correspondante.

Les challenges de cette section ont pour objectif de nous faire explorer les fondements du cryptosystème RSA, tout en mettant en évidence les erreurs courantes et les failles d’implémentation qui ont, dans certains cas, conduit à des attaques réelles.


\subsection{RSA Multi-Factor Attack}
Dans le challenge \textit{ManyPrime}, nous disposons d’un fichier contenant un module RSA $n$, un exposant public $e$ et un ciphertext $ct$. L’énoncé nous donne deux indices explicites : l’auteur indique qu’il utilisera "over 30" facteurs premiers et renvoie vers la méthode des courbes elliptiques (ECM). Ces indications orientent notre stratégie d’attaque : extraire un grand nombre de facteurs premiers relativement petits grâce à l’ECM, puis retrouver la clé privée pour déchiffrer le message.


\subsubsection{Objectifs}
Notre objectif est de récupérer le flag contenu dans le ciphertext. Concrètement, nous devons factoriser \textit{n} en l’ensemble de ses facteurs premiers, puis calculer $d = e^{-1} \pmod{\varphi(n)}$ où $\varphi(n)=\prod_i (p_i-1)$, et enfin déchiffrer $\mathrm{ct}$ pour obtenir le \textit{plaintext} (le \textit{flag}).


\subsubsection{Méthode}

Notre méthode de résolution exploite une vulnérabilité dans la conception du
module RSA~: sa construction à partir d'un grand nombre de petits facteurs
premiers. Cette approche affaiblit considérablement sa résistance aux
algorithmes de factorisation modernes comme l'ECM (\textit{Elliptic Curve Method}),
qui sont particulièrement efficaces pour trouver des facteurs de taille modeste.

Pour la mise en œuvre pratique, nous avons configuré un environnement Python
avec les bibliothèques \texttt{primefac}, pour son implémentation de l'ECM,
et \texttt{pycryptodome} pour les opérations arithmétiques modulaires.
Le processus de factorisation a été réalisé via une boucle itérative qui
invoque \texttt{primefac.ecm()} pour extraire progressivement chaque facteur
premier $p$ du module $n$, jusqu'à sa décomposition complète.

Une fois l'ensemble des facteurs premiers obtenu, nous avons validé leur produit
pour nous assurer qu'il correspondait bien au module $n$ original. Nous avons
ensuite calculé la fonction indicatrice d’Euler $\varphi(n) = \prod (p_i - 1)$
et déterminé l’exposant privé $d$ en résolvant l’équation
$e \cdot d \equiv 1 \pmod{\varphi(n)}$. Finalement, le message original a été
restauré en déchiffrant le ciphertext $ct$ par exponentiation modulaire
($pt = ct^d \pmod{n}$).
\subsubsection{Résultat}
Notre script, présenté en \hyperref[annexe:script-manyprime]{Annexe F} extrait plusieurs facteurs premiers et les affiche sur le terminal. Les valeurs obtenues sont présentées \hyperref[tab:facteurs]{Table 2}.

    \begin{table}[h!]
      \centering
      \begin{tabular}{lll}
      $p_1 = 17281246625998849649$ &
      $p_2 = 9389357739583927789$ &
      $p_3 = 10638241655447339831$ \\
      $p_4 = 16656402470578844539$ &
      $p_5 = 14100640260554622013$ &
      $p_6 = 9303850685953812323$ \\
      $p_7 = 17174065872156629921$ &
      $p_8 = 14963354250199553339$ &
      $\dots$ \\
      \end{tabular}
      \caption{Facteurs premiers extraits par ECM}
      \label{tab:facteurs}
    \end{table}


Après les calculs de vérification et de déchiffrement, nous obtenons le message en clair suivant :

    \begin{center}
      \texttt{crypto\{700\_m4ny\_5m4ll\_f4c70r5\}}
    \end{center}


\subsection{Cryptanalyse RSA avec exposant faible}
Dans cette sous-partie, nous présentons l’analyse du challenge \textit{Vote for Pedro} qui illustre une vulnérabilité cryptographique classique dans l’implémentation du chiffrement RSA. Ce challenge met en avant les dangers liés à l’utilisation d’un exposant public faible, particulièrement lorsque combiné avec des messages de petite taille et l’absence de mécanisme de padding approprié. En le résolvant, nous montrons comment il est possible de forger des signatures sans disposer de la clé privée, compromettant ainsi l’intégrité du système d’authentification.


\subsubsection{Objectifs}
Notre objectif principal dans ce challenge est d’obtenir un flag en votant pour Pedro avec une signature valide émise par Alice. Le serveur vérifie la signature du vote en utilisant la clé publique d’Alice et retourne le flag uniquement si le message déchiffré correspond exactement à la chaîne \textbf{VOTE FOR PEDRO}. La difficulté réside dans l’impossibilité d’accéder à la clé privée d’Alice pour signer le message légitimement.


\subsubsection{Méthode}
Le challenge nous fournit deux éléments essentiels : le script du serveur et la clé publique d’Alice. En analysant le script serveur (cf. \hyperref[annexe:script-vote]{Annexe G}), nous révélons le mécanisme de vérification des signatures. Le serveur reçoit un vote signé sous forme hexadécimale, applique la vérification RSA en calculant le vote à la puissance de l’exposant public modulo $N$, puis convertit le résultat en bytes. Le message est ensuite extrait en prenant la partie suivant le dernier octet nul avant d’être comparé avec la chaîne attendue.

La clé publique d’Alice présente une particularité cruciale : l’exposant public $e = 3$. Cette valeur faible, combinée avec l’absence de padding robuste, crée une vulnérabilité exploitable en permettant une attaque par extraction de racine cubique. En effet, lorsque le message original est inférieur à la racine cubique de $N$, l’opération de signature peut être inversée sans recours au modulo, rendant possible la forge de signature.


Le principe mathématique de notre attaque repose sur l'équation de vérification RSA standard, $\text{vote}^e \pmod{N}$. L'exposant public étant faible ($e = 3$), si le message $M$ est suffisamment petit pour que $M < \sqrt[3]{N}$, l'opération modulo devient superflue. L'équation se simplifie alors en $\text{vote}^3 = M$, nous permettant d'obtenir la signature par un simple calcul de racine cubique. Le message \textbf{VOTE FOR PEDRO} n'étant pas un cube parfait, notre stratégie a été de trouver un entier $S$ tel que $S^3$ partage les mêmes bits de poids faible que le message, ce qui est suffisant car le serveur ignore les bits de poids fort lors de la vérification.

Pour ce faire, nous avons implémenté un algorithme, \texttt{cube\_root\_2\_pow}, qui calcule cette racine cubique bit par bit. En procédant par raffinement successif, il garantit la convergence vers une solution valide. Sur le plan technique, notre script établit une connexion socket avec le serveur, convertit le message cible en entier, puis exécute l'algorithme pour calculer la signature forgée. Celle-ci est ensuite convertie en hexadécimal et transmise dans un payload JSON pour validation.

\subsubsection{Résultat}
L’exécution de notre script de résolution, présenté dans l'\hyperref[label]{Annexe ..} produit le résultat suivant après connexion au serveur :

    \begin{verbatim}
    Place your vote. Pedro offers a reward to anyone who votes for him!
    {"flag": "crypto{y0ur_v0t3_i5_my_v0t3}"}
    \end{verbatim}
